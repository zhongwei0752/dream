// MooTools: the javascript framework.
// Load this file's selection again by visiting: http://mootools.net/more/695befe97bdd68606cbfd2236812374e 
// Or build this file again with packager using: packager build More/Events.Pseudos More/Fx.Scroll
/*
 ---

 script: More.js

 name: More

 description: MooTools More

 license: MIT-style license

 authors:
 - Guillermo Rauch
 - Thomas Aylott
 - Scott Kyle
 - Arian Stolwijk
 - Tim Wienk
 - Christoph Pojer
 - Aaron Newton
 - Jacob Thornton

 requires:
 - Core/MooTools

 provides: [MooTools.More]

 ...
 */

MooTools.More = {
    'version': '1.4.0.1',
    'build': 'a4244edf2aa97ac8a196fc96082dd35af1abab87'
};


/*
 ---

 name: Events.Pseudos

 description: Adds the functionality to add pseudo events

 license: MIT-style license

 authors:
 - Arian Stolwijk

 requires: [Core/Class.Extras, Core/Slick.Parser, More/MooTools.More]

 provides: [Events.Pseudos]

 ...
 */

(function(){

    Events.Pseudos = function(pseudos, addEvent, removeEvent){

        var storeKey = '_monitorEvents:';

        var storageOf = function(object){
            return {
                store: object.store ? function(key, value){
                    object.store(storeKey + key, value);
                } : function(key, value){
                    (object._monitorEvents || (object._monitorEvents = {}))[key] = value;
                },
                retrieve: object.retrieve ? function(key, dflt){
                    return object.retrieve(storeKey + key, dflt);
                } : function(key, dflt){
                    if (!object._monitorEvents) return dflt;
                    return object._monitorEvents[key] || dflt;
                }
            };
        };

        var splitType = function(type){
            if (type.indexOf(':') == -1 || !pseudos) return null;

            var parsed = Slick.parse(type).expressions[0][0],
                parsedPseudos = parsed.pseudos,
                l = parsedPseudos.length,
                splits = [];

            while (l--){
                var pseudo = parsedPseudos[l].key,
                    listener = pseudos[pseudo];
                if (listener != null) splits.push({
                    event: parsed.tag,
                    value: parsedPseudos[l].value,
                    pseudo: pseudo,
                    original: type,
                    listener: listener
                });
            }
            return splits.length ? splits : null;
        };

        return {

            addEvent: function(type, fn, internal){
                var split = splitType(type);
                if (!split) return addEvent.call(this, type, fn, internal);

                var storage = storageOf(this),
                    events = storage.retrieve(type, []),
                    eventType = split[0].event,
                    args = Array.slice(arguments, 2),
                    stack = fn,
                    self = this;

                split.each(function(item){
                    var listener = item.listener,
                        stackFn = stack;
                    if (listener == false) eventType += ':' + item.pseudo + '(' + item.value + ')';
                    else stack = function(){
                        listener.call(self, item, stackFn, arguments, stack);
                    };
                });

                events.include({type: eventType, event: fn, monitor: stack});
                storage.store(type, events);

                if (type != eventType) addEvent.apply(this, [type, fn].concat(args));
                return addEvent.apply(this, [eventType, stack].concat(args));
            },

            removeEvent: function(type, fn){
                var split = splitType(type);
                if (!split) return removeEvent.call(this, type, fn);

                var storage = storageOf(this),
                    events = storage.retrieve(type);
                if (!events) return this;

                var args = Array.slice(arguments, 2);

                removeEvent.apply(this, [type, fn].concat(args));
                events.each(function(monitor, i){
                    if (!fn || monitor.event == fn) removeEvent.apply(this, [monitor.type, monitor.monitor].concat(args));
                    delete events[i];
                }, this);

                storage.store(type, events);
                return this;
            }

        };

    };

    var pseudos = {

        once: function(split, fn, args, monitor){
            fn.apply(this, args);
            this.removeEvent(split.event, monitor)
                .removeEvent(split.original, fn);
        },

        throttle: function(split, fn, args){
            if (!fn._throttled){
                fn.apply(this, args);
                fn._throttled = setTimeout(function(){
                    fn._throttled = false;
                }, split.value || 250);
            }
        },

        pause: function(split, fn, args){
            clearTimeout(fn._pause);
            fn._pause = fn.delay(split.value || 250, this, args);
        }

    };

    Events.definePseudo = function(key, listener){
        pseudos[key] = listener;
        return this;
    };

    Events.lookupPseudo = function(key){
        return pseudos[key];
    };

    var proto = Events.prototype;
    Events.implement(Events.Pseudos(pseudos, proto.addEvent, proto.removeEvent));

    ['Request', 'Fx'].each(function(klass){
        if (this[klass]) this[klass].implement(Events.prototype);
    });

})();


/*
 ---

 script: Fx.Scroll.js

 name: Fx.Scroll

 description: Effect to smoothly scroll any element, including the window.

 license: MIT-style license

 authors:
 - Valerio Proietti

 requires:
 - Core/Fx
 - Core/Element.Event
 - Core/Element.Dimensions
 - /MooTools.More

 provides: [Fx.Scroll]

 ...
 */

(function(){

    Fx.Scroll = new Class({

        Extends: Fx,

        options: {
            offset: {x: 0, y: 0},
            wheelStops: true
        },

        initialize: function(element, options){
            this.element = this.subject = document.id(element);
            this.parent(options);

            if (typeOf(this.element) != 'element') this.element = document.id(this.element.getDocument().body);

            if (this.options.wheelStops){
                var stopper = this.element,
                    cancel = this.cancel.pass(false, this);
                this.addEvent('start', function(){
                    stopper.addEvent('mousewheel', cancel);
                }, true);
                this.addEvent('complete', function(){
                    stopper.removeEvent('mousewheel', cancel);
                }, true);
            }
        },

        set: function(){
            var now = Array.flatten(arguments);
            if (Browser.firefox) now = [Math.round(now[0]), Math.round(now[1])]; // not needed anymore in newer firefox versions
            this.element.scrollTo(now[0], now[1]);
            return this;
        },

        compute: function(from, to, delta){
            return [0, 1].map(function(i){
                return Fx.compute(from[i], to[i], delta);
            });
        },

        start: function(x, y){
            if (!this.check(x, y)) return this;
            var scroll = this.element.getScroll();
            return this.parent([scroll.x, scroll.y], [x, y]);
        },

        calculateScroll: function(x, y){
            var element = this.element,
                scrollSize = element.getScrollSize(),
                scroll = element.getScroll(),
                size = element.getSize(),
                offset = this.options.offset,
                values = {x: x, y: y};

            for (var z in values){
                if (!values[z] && values[z] !== 0) values[z] = scroll[z];
                if (typeOf(values[z]) != 'number') values[z] = scrollSize[z] - size[z];
                values[z] += offset[z];
            }

            return [values.x, values.y];
        },

        toTop: function(){
            return this.start.apply(this, this.calculateScroll(false, 0));
        },

        toLeft: function(){
            return this.start.apply(this, this.calculateScroll(0, false));
        },

        toRight: function(){
            return this.start.apply(this, this.calculateScroll('right', false));
        },

        toBottom: function(){
            return this.start.apply(this, this.calculateScroll(false, 'bottom'));
        },

        toElement: function(el, axes){
            axes = axes ? Array.from(axes) : ['x', 'y'];
            var scroll = isBody(this.element) ? {x: 0, y: 0} : this.element.getScroll();
            var position = Object.map(document.id(el).getPosition(this.element), function(value, axis){
                return axes.contains(axis) ? value + scroll[axis] : false;
            });
            return this.start.apply(this, this.calculateScroll(position.x, position.y));
        },

        toElementEdge: function(el, axes, offset){
            axes = axes ? Array.from(axes) : ['x', 'y'];
            el = document.id(el);
            var to = {},
                position = el.getPosition(this.element),
                size = el.getSize(),
                scroll = this.element.getScroll(),
                containerSize = this.element.getSize(),
                edge = {
                    x: position.x + size.x,
                    y: position.y + size.y
                };

            ['x', 'y'].each(function(axis){
                if (axes.contains(axis)){
                    if (edge[axis] > scroll[axis] + containerSize[axis]) to[axis] = edge[axis] - containerSize[axis];
                    if (position[axis] < scroll[axis]) to[axis] = position[axis];
                }
                if (to[axis] == null) to[axis] = scroll[axis];
                if (offset && offset[axis]) to[axis] = to[axis] + offset[axis];
            }, this);

            if (to.x != scroll.x || to.y != scroll.y) this.start(to.x, to.y);
            return this;
        },

        toElementCenter: function(el, axes, offset){
            axes = axes ? Array.from(axes) : ['x', 'y'];
            el = document.id(el);
            var to = {},
                position = el.getPosition(this.element),
                size = el.getSize(),
                scroll = this.element.getScroll(),
                containerSize = this.element.getSize();

            ['x', 'y'].each(function(axis){
                if (axes.contains(axis)){
                    to[axis] = position[axis] - (containerSize[axis] - size[axis]) / 2;
                }
                if (to[axis] == null) to[axis] = scroll[axis];
                if (offset && offset[axis]) to[axis] = to[axis] + offset[axis];
            }, this);

            if (to.x != scroll.x || to.y != scroll.y) this.start(to.x, to.y);
            return this;
        }

    });



    function isBody(element){
        return (/^(?:body|html)$/i).test(element.tagName);
    }

})();